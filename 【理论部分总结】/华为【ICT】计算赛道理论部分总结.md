<center><font size=7><b>【ICT】计算赛道</b></font></center>

<center><font size=6><b>理论部分（背记内容）</b></font></center>

+++

[toc]

+++



# 进程与线程

## 一、进程的概念

### 1、从源码到执行的3个阶段

​		（1）编译阶段

​		（2）加载阶段

​		（3）执行阶段

### 2、程序的执行过程依赖的3种硬件状态

​		（1）<font size=4 color='red'><b>`寄存器`</b></font>。程序运行至少会用到寄存器 PC、LR、SP、FP，它们保存着函数计算的 状态。

​		（2）<font size=4 color='red'><b>`内存`</b></font>。程序的指令，以及在运行时读取和写入的数据都存储在内存中。

​		（3）<font size=4 color='red'><b>`I/O 信息`</b></font>。程序可能需要读写文件，涉及磁盘I/O。另外，在Linux系统中，默认情 况下，每个程序都有三个打开的文件描述符，即标准输入、标准输出、标准错误，分别用于接 收用户输入、显示输出结果和错误信息。

### 3、程序的并发执行带来的影响

​		（1）<font size=4 color='red'><b>`程序执行的间断性`</b></font>。由于 CPU 需要在各程序之间来回切换，使得程序的执行具有 间断性。

​		（2）<font size=4 color='red'><b>`资源共享带来的制约性`</b></font>。由于并发执行的程序需要共享系统中的 CPU、内存等资 源，任一程序对这些资源状态的改变都会影响其他程序的运行环境，造成程序之间存在制约 关系。

​		（3）程序只是对计算任务和数据的静态描述，无法刻画并发执行过程带来的这些新特 征。因此，为了对并发执行的程序加以描述与控制，操作系统引入了“进程”概念。

## 二、进程的描述

### 1、进程控制块(PCB， ProcessControlBlock)的数据结构structtask_struc 4方面内容

​		（1）<font size=4 color='red'><b>`描述信息`</b></font>。

​				① <font size=3 color='blue'><b>`进程标识符`</b></font>。每个进程都有唯一的进程标识符，所以操作系统是依靠进程标识符来 区分不同进程的。

​				② <font size=3 color='blue'><b>`用户标识号`</b></font>。每个进程都隶属于某个用户，为了加以区分，操作系统引入用户标识 符。

​				③ <font size=3 color='blue'><b>`家族关系`</b></font>。进程并不独立存在，通常与其他进程组成家族关系，便于操作系统进行 组织和管理。

​		（2）<font size=4 color='red'><b>`控制信息`</b></font>。

​				① <font size=3 color='blue'><b>`进程的状态信息`</b></font>。进程在活动期间处于就绪、运行、阻塞和终止等状态中的任意一 种。

​				②  <font size=3 color='blue'><b>`进程的优先级信息`</b></font>。进程优先级用来确定进程被调度到 CPU 上执行的优先程度。

​				③ <font size=3 color='blue'><b>`记账信息`</b></font>。进程的记账信息主要给出进程占有和利用资源的有关情况，包括占用 CPU 的时钟周期数、时间总和等。

​		（3）<font size=4 color='red'><b>`CPU上下文`</b></font>。CPU 上下文是指进程执行到某时刻时 CPU 各寄存器中的值，这些值代表着当前进程 活动的状态信息。在支持进程并发的场合，一个进程的执行是间断性获取 CPU 控制权的过程。

​		（4）<font size=4 color='red'><b>`资源管理信息`</b></font>。PCB中包含最多的是资源管理信息，其中包括关于存储器、文件系统和使用输入/输出 设备的信息等。

### 2、进程的4种状态

​		（1）<font size=4 color='red'><b>`就绪状态`</b></font>。进程处于就绪状态时，进程位于运行队列中，表明其已经获得除 CPU 之外的其他资 源。当进程被操作系统选中去占用 CPU 时，处于就绪状态的进程将转换为运行状态。

​		（2）<font size=4 color='red'><b>`运行状态`</b></font>。处于运行状态时，进程中的指令正在被 CPU 执行。只有处于就绪状态的进程才可以 转换为运行状态。进程在遇到以下几种情况时会退出运行状态：

​				① <font size=3 color='blue'><b>`当 CPU 被其他进程抢占或者进程主动让出 CPU 时，进入就绪状态`</b></font>。

​				②  <font size=3 color='blue'><b>`当进程需要等待资源或者等待一些事件发生而不得不退出执行时，进入阻塞状态`</b></font>。

​				③ <font size=3 color='blue'><b>`进程执行完毕后，通常发生执行完毕但资源未被回收或者是执行完毕且资源已回收这2种情况，进入终止状态`</b></font>。

​		（3）<font size=4 color='red'><b>`阻塞状态`</b></font>。处于阻塞状态时，进程通常是在等待着某些外部事件发生。在这些事件到来后，进程具 备了继续执行的条件，但还无法直接获得 CPU 控制权，因此发生`等待的时间已发生`进入就绪状态。处 于阻塞状态的进程也可以通过其他方式唤醒。根据唤醒的困难程度，唤醒方式可以分为 三种：

​				① <font size=3 color='blue'><b>`轻度阻塞状态`</b></font>。可以被一些系统调用(System Call)显式地唤醒或者由一些急需处 理的信号唤醒；

​				②  <font size=3 color='blue'><b>`中度阻塞状态`</b></font>。中度阻塞状态，可以被显式地唤醒，或是被一些致命信号(可能导致进程终止) 唤醒；

​				③ <font size=3 color='blue'><b>`深度阻塞状态`</b></font>。深度阻塞状态，只能被显式地唤醒，不可因信号退出。

​		（4）<font size=4 color='red'><b>`终止状态`</b></font>。进程的终止状态又包括僵尸状态和死亡状态。 <font size=3 color='blue'><b>`僵尸状态`</b></font>代表着此时该进程的父进程并未回收此进程，也未回收此进程所占用的资源（包括 PCB）。如果父进程早于子进 程退出，操作系统会让init进程成为子进程的父进程，所以在子进程退出后将由init进程回 收子进程占用的相关资源。当父进程回收了此进程的资源，进程进入<font size=3 color='blue'><b>`死亡状态`</b></font>，生命周期完全结束。

## 三、进程的控制

### 1、用于进程控制的4个原语

​		（1）<font size=4 color='red'><b>`创建`</b></font>。新创建的进程通常称为子进程，创建出子进程的进程是其真正父进程。进程一般通过以下四种方式创建：

​				① <font size=3 color='blue'><b>`为批处理作业创建`</b></font>。操作系统从外存中的批处理作业控制流中获取新任务，并为 其创建进程。

​				②  <font size=3 color='blue'><b>`用户登录系统`</b></font>。终端用户登录时，登录界面就需要运行在一个新进程中。

​				③ <font size=3 color='blue'><b>`系统进程为提供服务而创建`</b></font>。例如，当用户请求一个功能时，比如视频聊天，操作 系统会为其创建控制摄像头、喇叭、麦克风等的进程，不需用户自己去创建。

​				④  <font size=3 color='blue'><b>`由已存在的进程创建`</b></font>。例如，在多核 CPU 中，父进程创建子进程以实现并行工作。

<blockquote>
    前三种情况都是由操作系统来创建进程，最后一种是由父进程来创建新进程。
</blockquote>

​		（2）<font size=4 color='red'><b>`销毁`</b></font>。在操作系统中，进程的销毁操作可能由以下三种情况触发:

​				① 该进程已完成所要求的功能而正常终止；

​				② 由于某种错误导致非正常终止；

​				③ 父进程或是更高级别的祖先进程要求销毁某个子进程。

​		无论哪一种情况导致进程被销毁，进程都必须释放它所占用的各种资源和 PCB结构本 身，以利于资源的有效利用。

​		（3）<font size=4 color='red'><b>`阻塞`</b></font>。在一个进程等待某一事件(例如键盘输入数据、磁盘I/O 和其他进程发来的数据等)发 生但该事件尚未发生时，该进程调用阻塞原语来阻塞自己。

​		（4）<font size=4 color='red'><b>`唤醒`</b></font>。当等待队列中的进程所等待的事件发生时，等待该事件的所有进程都将被唤醒。

### 2、进程的创建

​		如果每个进程都从零开始创建，那必然有大量初始化工作（如初始化 PCB、构建虚拟内 存空间等）是重复的。类 UNIX操作系统提供创建原语函数——`fork()`/`clone()`:使用已有 的进程复制出新进程，相当于新进程完成了与已有进程同样的初始化工作。就像细胞分裂 一样，先将一个进程的核心内容复制一份，然后分裂成两个完整的进程。其中，`clone()`函数主要用于线程创建，`fork()`函数创建的进程是已有进程的一个副本，执行的程序也与已有进 程相同。

### 3、从进程 运行的三个必备要素考虑：

​		① 操作系统需要通过 PCB对进程进行管理，所以fork()函数先 为新进程创建 PCB，并进行初始化；

​		② 进程运行时的相关状态及数据保存在 CPU 上下文 中。fork()函数通过复制父进程的 CPU 上下文到新进程的 PCB 中，使得新进程拥有与其 父进程相同的执行环境；

​		③ 由于进程实体是存储在内存中的，进程必须拥有物理内存空间 才能执行，所以fork()函数也需要为新进程分配物理内存。

### 4、PCB的复制

​		在`fork()`函数中，新进程 PCB的初始化通过复制其父进程的 PCB来实现，由此继承父 进程的进程状态等信息。

### 5、CPU上下文的复制

​		经过函数`dup_task_struct()`之后，新进程拥有了自己的 PCB，但此时新进程只是一个未初始化的进程，还不可运行。拥有 PCB的新进程还需要有执行环境才能执行。由于父进 程的一些运行状态被存储在 CPU 的寄存器中，新进程可以通过复制父进程 CPU 上下文的 状态，来拥有与父进程相同的执行环境。

### 6、地址空间的复制

​		函数`fork()`创建的新进程与父进程有着完全一样的地址空间，这可以用两种方案来实 现。

​		<b>第一种方案</b>是给新进程分配与父进程等量的物理内存，并把父进程在内存中的所有数 据都给新进程复制一份。这个过程需要完成的事情有：

​				（1）分配物理页作为新进程的页表；

​				（2）复制父进程页表内容；

​				（3）对照父进程页表，为新进程页表项分配物理页并建立映射关系；

​				（4）将父进程的物理页内容复制到新进程相应页中。

​		由于第（3）、（4）步中分配物理页并复制旧页内容都是非常耗时的操作，父进程拥有的物 理页越多，这个过程的时间开销就越大。然而，新进程创建成功后通常立即装载新的程序到 地址空间，之前复制的内容只有很少数被使用，而且其内容也会被覆盖。例如，shell创建的 新进程需要立马执行用户命令指定的程序。那么，之前复制父进程整个地址空间的操作是 不必要的。

​		因此，openEuler选择了<b>第二种实现方案</b>：在新进程中建立与父进程同样的映射关系， 让两个进程以只读的形式共享同一片物理内存，直到某个进程试图修改某一页内容时，再为 其分配新的物理页并复制原页面内容，这被称作<font size=4 color='red'><b>`写时复制`</b></font>（copy-on-write）

​		两种方案关键的不同点在于，<font size=4 color='red'><b>前者`复制了父进程拥有的所有物理页的内容`， 而后者`仅复制了映射关系`</b></font>。

### 7、内核收到缺页异常后，如何处理才能做到允许当前进程继续执行写操作而不影响其他进程?

​		首先内核需要确认该缺页异常是由于写时复制引起的，之后内核会将触发缺页异常 的只读物理页内容复制到一个新的可读写物理页中，并在当前进程页表中的映射关系中用 新页替换旧页。这样就在进程不知情的情况下，将写操作的对象换成了新物理页。由于新物理页并未映射到其他地址空间，所以内容的变化也不会影响其他进程。

​		以下是openEuler解决这两个部分的关键技术：

​				（1）<font size=4 color='red'><b>`复制映射关系`</b></font>。进程地址空间分为内核空间与用户空间，映射关系的复制也分为两部分完成。openEuler 在全局层面维护了一份主内核页表，由于所有进程共享内核，所有进程的内核空间部分都是 对主内核页表的一个复制或引用。因此，所有进程的内核空间都是相同的。不同进程的用 户空间可以不同，所以函数fork()需要为新进程的每一级页表分配物理页，并从父进程对应 页表中复制所有页表项。

​				（2）<font size=4 color='red'><b>`写时复制触发的缺页异常处理`</b></font>。首先，异常处理器需要检查错误类型；接着，异常处理器需要判断 PTE 页表项是否为空，如果不为空，说 明其确实映射着一个物理页；然后，异常处理器可以通过标志 FAULT_FLAG_WRITE 确定缺页异常的触发原因；至此，异常处理器可以断定缺页异常是由对写时复制页面执行写操作 导致的，进入相应的处理函数。

### 8、新创建的进程如何加载一个新程序？

​		当前操作系统采用的一种普遍方案是，先将各种程序编译成二进制可执行文件存在外 存中，当有需要时，进程从外存中将所需的可执行文件内容装入地址空间，然后从中获取程 序入口地址并开始执行新的程序指令。

​		openEuler中由 exec函数簇来实现该方案。此处将调用exec函数簇的进程称为调用进程。exec函数簇用 新程序替换调用进程地址空间中的程序实体，包括代码段、数据段，还为调用进程分配新的用户堆栈。

### 9、`exec`函数数簇的系列函数的挑战有哪些？

​		①用户怎么告诉操作系统自己需要哪个程序？

​		②操作系统怎么根据给定的信息去外存中找到所需的可执行文件?

​		③操作系统怎么将找到的文 件内容装载到调用进程的地址空间中?

​		④操作系统怎么为进程构建新的执行环境，使其能 从新程序的入口地址开始执行？

### 10、以`ELF`文件为例，程序装载的步骤？

​		（1）<font size=4 color='red'><b>`exec函数簇的系列函数接口`</b></font>。用户必须通过exec接口向操作系统传递一些参数，例如文件名、文件路径、环境变量 等。这样，操作系统内核才能去外存加载正确的可执行文件。

​		（2）<font size=4 color='red'><b>`可执行文件的寻找与打开`</b></font>。在openEuler中，文件系统的每个目录文件或文件都对应一个inode对象。inode对象 记录了一个文件的重要信息，包括文件字节数、拥有者、读写权限、在外存的位置等。用户将文件名传给内核，表明自己想要操作的文件。

​		（3）<font size=4 color='red'><b>`可执行文件的装载`</b></font>。

​		（4）<font size=4 color='red'><b>`新程序的执行`</b></font>。内核将代码段、数据段等映射到内存后，还需要更新这些 Segment在地址空间中的起 始地址和结束地址。

### 11、进程终止和资源回收的步骤

​		（1）<font size=4 color='red'><b>`用户空间资源的回收`</b></font>。在进程终止时，内核优先回收的是当前进程所占用且不与其他进程共享的用户空间资源。映射到进程用户空间的物理内存有三个组成 部分:**分配到的物理内存**、**页表占用的物理内存**、**内存描述符占用的物理内存**。所以，内核 也需要分三个过程回收这些资源。

​		（2）<font size=4 color='red'><b>`状态信息的发送与僵尸状态的设置`</b></font>。回收了大部分资源后，即使当前进程被调度器再次选中，也无法再运行，所以内核会将 当前进程设为僵尸状态(EXIT_ZOMBIE)，使其被调度器忽略。

​		（3）<font size=4 color='red'><b>`内核资源的回收`</b></font>。

​		（4）<font size=4 color='red'><b>`为所有子进程寻找新父进程`</b></font>。

## 四、系统调用

### 1、操作系统通过引入进程，允许多个程序共享 CPU 等硬件资源。那么，进程之间应该以 何种方式使用机器上的硬件资源呢?

​		操作系统 保持对 CPU 的控制权，并负责硬件资源的管理；限制进程直接操作硬件资源；在进程希望 执行受限的操作时，进程需要将 CPU 控制权移交给操作系统，由操作系统执行进程所请求 的服务。通过这种方式，进程之间以受控的方式来共享资源。

### 2、在实现`1`中的思想时会面临一下关键挑战：①如何限制进程所能进行的操作? ②操 作系统如何为进程服务? 现代计算机基于处理器硬件和操作系统软件的协作来解决这两个挑战。

​		在硬件方面，CPU 模式分为内核模式与用户模式，并用寄存器的特定字段标识当前模 式。

​		在软件方面，将受限的操作设计成内核功能，并以系统调用的形式暴露给用户进程。用 户通过暴露的系统调用接口来使用操作系统的关键功能。

### 3、系统调用是如何实现的？

​		（1）<font size=4 color='red'><b>`库函数的调用`</b></font>。在用户态下，用户进程需配置参数寄存器并调用指令 SVC 去发起系统调用。

​		（2）<font size=4 color='red'><b>`异常处理`</b></font>。用户进程执行指令SVC时就会产生一个异常。CPU 会先对该异常进行初步处理，自 动执行以下操作:

​				①将 PSTATE相关寄存器的数据作为字段内容一起存入寄存器SPSR_EL1中。

​				②将返回地址保存到寄存器 ELR_EL1中，使得当该进程从异常处理程序返回时可以从它离开的地方继续执行。对系统调用而言，保存的是系统调用发生时即将执行的下一 条指令的地址。 

​				③将异常屏蔽寄存器的4个掩码位 DAIF置为1，即关中断。

​				④如果是同步异常，将生成异常的原因保存到寄存器 ESR_EL1中。

​				⑤将寄存器组 PSTATE中寄存器 CurrentEL的字段 EL 置为1，即把异常级别提升 到 EL1。

​		在 CPU 完成初步处理之后，操作系统需执行异常处理程序来进一步处理该异常。

​		同步异常处理函数可执行三个步骤:

​				①<font size=3 color='blue'><b>`CPU 状态保存`</b></font>；操作系统进行同步异常处理时，首先应保存进程在用户状态时的 CPU 状态，以备异常 处理结束并返回用户态后，能从中断发生的地方继续执行该进程。

​				②<font size=3 color='blue'><b>`触发异常原因判断`</b></font>；

​				③<font size=3 color='blue'><b>`调用相应异常处理函数及传递参数`</b></font>。

​		（3）<font size=4 color='red'><b>`系统调用服务函数的查找`</b></font>。异常处理过程是一致的，无论执行哪个系统调用，都会由软硬件配合来执行上述流程。

​		（4）<font size=4 color='red'><b>`服务函数的执行`</b></font>。在根据系统调用表找到对应的服务函数后，内核将执行该函数来为用户进程服务。

​		（3）<font size=4 color='red'><b>`异常返回`</b></font>。得到了用户进程期望的结果，接下来要做的是异常返回(返回用户态)，并继续执行用户 进程。

## 五、进程切换

### 1、进程切换的过程

​		（1）<font size=4 color='red'><b>`异常处理`</b></font>。

​		（2）<font size=4 color='red'><b>`进程调度`</b></font>。

​		（3）<font size=4 color='red'><b>`切换上下文的保存与恢复`</b></font>。

## 六、线程

### 1、线程的基本概念

​		<font size=4 color='red'><b>`进程`</b></font>：是指⼀个内存中运⾏的应⽤程序，每个进程都有⼀个独⽴的内存空间，⼀个应⽤程序可以同时运⾏多个进程；进程也是程序的⼀次执⾏过程，是系统运⾏程序的基本单位；系统运⾏⼀个程序即是 ⼀个进程从创建、运⾏到消亡的过程。
​		<font size=4 color='red'><b>`线程`</b></font>：线程是进程中的⼀个执⾏单元，负责当前进程中程序的执⾏，⼀个进程中⾄少有⼀个线程。⼀个进程中是可以有多个线程的，这个应⽤程序也可以称之为多线程程序。

​		<font size=4 color='red'><b>`简⽽⾔之`</b></font>：⼀个程序运⾏后⾄少有⼀个进程，⼀个进程中可以包含多个线程

### 2、线程与进程的主要区别是什么？

​		（1）<font size=4 color='red'><b>`是否有独立的地址空间`</b></font>。**进程拥有独立的地址空间**。一个进程发生崩溃，不会对操作系统中的其他进程产生影 响。**线程没有自己独立的地址空间**，而是同一个线程组的所有线程共享相同的地址空间，但 每个线程在共享地址空间中有自己的栈。

​		（2）<font size=4 color='red'><b>`线程更为轻量级`</b></font>。相较于进程，线程的轻量级体现在**线程创建**、**线程切换**两个方面。

​		（3）<font size=4 color='red'><b>`通信方式`</b></font>。由于每个进程拥有相互隔离的地址空间，因此进程间的通信较为复杂。进程间通信通 过共享内存、消息队列以及套接字等方式实现。一个进程的多个线程之间共享同一个地址 空间，它们通过共享数据(如全局变量)即可实现通信。但是，多个并发线程在访问同一共享 数据时，将产生竞争。因此，在多线程并发访问共享数据时，操作系统需要提供互斥与同步 等特殊的通信机制。

### 3、线程的三种模型

​		在多线程操作系统中，线程的实现模型可以分为三种:**在用户空间实现的线程称为用户级线程**；**在内核空间实现的线程称为内核级线程**；**混合型线程是用户级线程和内核级线程的组合实现**。

​		（1）<font size=4 color='red'><b>`用户级线程`</b></font>。在线程的概念提出之初，操作系统内核还未提供线程支持，当时出于稳定性考虑，并未 修改内核而是选择在用户空间使用线程库来实现线程，也就是用户级线程。系统开发人员 将线程的创建、通信、同步及销毁等功能都封装在线程库中，无须借助系统调用来实现。用 户级线程仅存在于用户空间中，其相关管理工作均由用户进程完成。内核不能感知用户级 线程的存在，而是把隶属于同一个用户进程的所有用户级线程当成一个进程来实施管理。 所以，用户级线程与内核调度实体是多对一的关系。这种实现模型有以下两个特点。

​				①<font size=3 color='blue'><b>`用户级线程的调度算法和调度过程可由用户自行决定，与操作系统内核无关`</b></font>。

​				②<font size=3 color='blue'><b>`用户级线程的切换并不会导致进程的切换，而是在内核不参与的情况下完成线程 上下文切换`</b></font>。

​		（2）<font size=4 color='red'><b>`内核级线程`</b></font>。与用户级线程相对应，内核级线程是由操作系统内核进行管理的。内核向用户进程提 供相应的系统调用，以供用户进程创建、执行、撤销线程。在这类系统中，用户进程中的线程与内核调度实体是一对一的关系。内核级线程就是系统调度的最小单位，既 可以被调度到一个 CPU 上并发执行，也可以被调度到不同 CPU 上并行处理。若是一个线 程被阻塞，操作系统可以调度该用户进程的其他线程去执行，而不至于阻塞整个用户进程。虽然内核级线程似乎解决了用户级线程的缺点，但是内核级线程的管理与调度需要由 内核完成。这意味着，每次线程切换都需要陷入内核态，陷入过程会带来不小的开销，所以 内核级线程的切换代价要更大。此外，内核需要维护一份线程表去管理内核级线程。由于 内核资源有限，能维持的线程数量也有限，因此其扩展性不如用户级线程。

​		（3）<font size=4 color='red'><b>`混合型线程`</b></font>。上述两种线程的实现模型都有各自缺点，有些操作系统(如Solaris操作系统)采用用户 级线程和内核级线程的组合的方式实现线程管理，尽可能利用各自的优点而规避缺点。

<style>
  table td,table td {
      text-align:left;
      vertical-align: middle;
  }
  table tr:odd{
      background:#faa;
  }
</style>
<table border="1">
  <tr>
      <th><center>线程实现模型</center></th>
      <th><center>优点</center></th>
      <th><center>缺点</center></th>
  </tr>
  <tr>
      <td>用户级线程模型</td>
      <td>1、用户自行决定调度算法</br>2、线程切换在用户态，开销小</td>
      <td>1、用户进程的多个线程不能并行执行</br>2、用户进程因某个线程阻塞而阻塞</td>
  </tr>
  <tr>
      <td>内核级线程模型</td>
      <td>1、线程可在不同的 CPU上并行处理</br>2、某线程阻塞,其他线程可继续执行</td>
      <td>1、线程创建、切换需陷入内核态,开销大</br>2、占用内核资源</td>
  </tr>
  <tr>
      <td>混合型线程模型</td>
      <td>上述优点都具备</td>
      <td>高度复杂，实现困难</td>
  </tr>
</table>

​		openEuler采用的是上述三种线程实现模型中的<font size=5 color='red'><b>`内核级线程模型`</b></font>。

### 4、openEuler中线程的生命周期

​		创建、就绪、运行、阻塞、终止

### 5、进程切换的步骤

​		地址空间切换、内核栈切换、上下文切换



# 内存管理

## 一、内存访问：从直接到间接

### 1、什么是虚拟内存

​		虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。

### 2、操作系统引入虚拟内存带来了哪些好处？

​		（1）<font size=4 color='red'><b>`在单一的物理内存上，为每个进程提供了拥有全部内存的假象`</b></font>。

​		（2）<font size=4 color='red'><b>`未进程之间的隔离提供了基础`</b></font>。

## 二、分页

### 1、基本思想

​		在操作系统中，对于地址空间的管理，一种方法是将地址空间划分成不同长度的分区，每个进程被加载到其中一个分区中运行。

​		当前大多数操作系统采用分页的地址空间管理方法，它的基本思想是将进程的虚拟空间地址分割成固定长度的单元，称为将物理地址空间也分割成固定长度的单元（**通常取 4KB**），称为页（Page）；页与页框的长度相等。

​		在这种内存管理方式下，进程在被装入内存时，不再以整个进程为单位，而是以页为单位，所以进程不再需要存放在一块儿连续的物理地址空间，而可存放在物理地址不一定连续的页框中。

### 2、页、页框号、页表

​		为了记录每个页所分配的页框，操作系统使用一个表来为每个进程记录其页号（Page Numbers）与页框号（Page Frame Numbers）的映射关系，这个表称为页表。

### 3、分页机制的好处

​		（1）<font size=4 color='red'><b>`减少了内存碎片`</b></font>。

​		（2）<font size=4 color='red'><b>`页共享`</b></font>。不同的进程可以将虚拟地址映射到同一个页框，实现页的共享，以减少重复内容的存储。

### 4、空闲页管理

​		当进程被加载到内存中执行时，操作系统需要为其运行分配物理内存。因此，操作系统需要记录并管理目前计算机系统中空闲的页框。最简单的页框管理方式是：对于未分配的页框，操作系统通过维护一个空闲页框链表进行管理；当进程请求分配页框时，操作系统从链表头取下空闲页框分配给进程。

### 5、buddy（伙伴）系统是为了解决哪些问题？

​		解决页框总容量足够大，但地址不连续的问题。

### 6、buddy系统的基本思想是什么？

​			在分配页框之初就将页框以连续内存的形式组织起来；在页框分配时尽可能按所需连续页框的数目分配对应数量的页框；在页框回收时尽量将页框合并为连续的页框块。

### 7、buddy系统的优缺点各是什么？

​		<font size=4 color='red'><b>`优点`</b></font>：原理较为简单，外部碎片比较少并且可分配连续的物理内存。

​		<font size=4 color='red'><b>`缺点`</b></font>：内部碎片问题比较严重，同时在页框块回收时，buddy系统仅考虑与伙伴块合并，这使得有些相邻的、大小相同的空闲块没有合并，降低了内存的利用率。

### 8、地址转换过程

​		（1）从虚拟地址中得到页号及偏移

​		（2）利用页号及页表基址寄存器获得页表项（Page Table Entry, PTE）的物理地址

​		（3）从该物理地址中读取PTE的值以及页框号

​		（4）利用页框号计算物理地址

### 9、操作系统在地址转换中要承担的3项职责

​		（1）建立页表，保存页表基址

​		（2）设置页表基址寄存器

​		（3）处理访存异常

## 四、更小的页表

### 1、标准大页的缺点是什么？

​		大页的数量与长度必须在内核启动时指定，并需要在内存中预先留出大页池所需的内存。

## 五、物理内存扩充

### 1、操作系统要实现页的换入与换出，面临的两个问题是什么？

​		（1）在内存满后，操作系统应该选择哪个或哪些页换出的内存：如果选择经常被用到的页，在换出后内存马上又要用到，这样不仅不能降低内存紧张的情形，反而会增加系统的负担。

​		（2）在页换出到交换空间后，操作系统再次访问该页时，应该如何在交换空间中定位和记载该页。

### 2、openEuler中页交换的实现步骤有哪些？

​		（1）页换出。

​				① 分配交换空间块

​				② 更新PTE

​				③ 将数据写入交换区

​				④ 释放内存页

​		（2）页换入。

### 3、常用的页置换策略主要有哪3种？

​		（1）随机淘汰

​		（2）先进先出

​		（3）最近最久未使用策略

### 4、什么是匿名页的回收

​		当发生内存回收时，openEuler将访问LRU链表，根据各个页的访问情况在活跃链表与非活跃链表之间移动页记录，再选择非活跃链表末尾的多个记录所对应的页进行回收。



# 文件系统

## 一、硬件基础

### 1、硬盘的组成部分有哪些？

​		主轴、盘片、磁头、磁盘臂

### 2、磁盘的读写操作过程时什么样的

​		首先，磁盘驱动器需要将磁头移动到该扇区所在的磁道，这个过程称为寻道；其次，由于寻道结束后磁头不一定对准所要访问的扇区，因此磁盘驱动器转动主轴将该扇区旋转到磁头下，这个过程称为旋转；最后，当该扇区位于磁头下时，磁头即可从已定位的特定扇区读取或写入数据，这个过程称为传输。在硬盘读写的过程中，寻道以及旋转操作占了整个读写过程的主要时间开销。在磁盘上，读写一次数据所需的时间开销包括寻道时间、延迟时间及数据传输时间。

### 3、什么是文件？

​		从普通用户的视角看：文件是一个字节序列，其每个字节都可以呗读取或写入。

​		从应用程序员的视角看：文件时对磁盘和其他I/O设备的抽象，它隐藏了I/O设备的硬件特性和使用细节，使得I/O设备易于使用，

### 4、openEuler操作系统默认使用的文件系统是什么？

​		`Ext4`

## 二、文件系统的基本实现

### 1、数据块、inode块和结构

​		（1）<font size=4 color='red'><b>`数据块`</b></font>：保存文件数据的磁盘块称为数据块。

​		（2）<font size=4 color='red'><b>`inode 块`</b></font>：保存 inode 信息的磁盘块称为inode 块。一个 inode块可保存多个inode项。

​		（3）<font size=4 color='red'><b>`inode 结构`</b></font>：内存中的inode数据结构称为inode 结构。

### 2、`inode`具体包含的六类信息是什么？

​		（1）文件的大小

​		（2）文件所有者

​		（3）文件的权限

​		（4）文件的访问时间和修改时间

​		（5）链接数

​		（6）文件数据块的地址



# 系统虚拟化

## 一、虚拟机监视器

### 1、虚拟化基本概念

​		虚拟化是指把尸体计算机的物理资源抽象成逻辑资源，基于这些逻辑资源构建与实体计算机架构类似、功能等价的逻辑计算机。

### 2、VMM作为硬件的控制者和虚拟机的管理者主要有3个设计目标

​		（1）<font size=4 color='red'><b>`同质性`</b></font>：指应用系统程序在虚拟机上运行时，除时间因素和资源可用性外，表现在物理机上运行一致。

​		（2）<font size=4 color='red'><b>`资源受控性`</b></font>：指VMM全权管理物理机硬件资源，虚拟机不可直接访问和操作不属于自己的硬件资源

​		（3）<font size=4 color='red'><b>`高效性`</b></font>：指虚拟机种所运行程序的性能应接近于同等配置物理机上直接运行程序的性能

### 3、虚拟化的3个好处

​		（1）资源利用率高

​		（2）具有灵活性

​		（3）具有隔离性

### 4、虚拟化的类型

​		总体上，系统虚拟化技术可分为`全虚拟化`和`半虚拟化`。

​		（1）<font size=4 color='red'><b>`全虚拟化`</b></font>：在全虚拟化结构下虚拟出的硬件环境与真实物理机的环境是同质的，因此，客户机操作系统不知道自己运行在虚拟的环境中，也无需对其操作系统进行任何更改。

​		（2）<font size=4 color='red'><b>`半虚拟化`</b></font>：又称为“协同虚拟化”。客户机操作系统能够意识到自己处于虚拟化环境，其所在的虚拟化环境种的部分硬件抽象与真实硬件不同，不满足同质性。

### 5、关于虚拟化技术的核心

​		`全虚拟化`与`半虚拟化`是系统虚拟化的两个分类，而系统虚拟化技术实现的核心是`VMM`。

​		`VMM`主要有两种类型：`Type 1 VMM`（裸金属架构VMM）和`Type 2 VMM`（寄居架构）。

​		其中，个人计算机上常用的是`Type 2 VMM`，服务器中常用的是`Type 1 VMM`

## 二、基于Linux内核的虚拟机监视器

### 1、几个小知识点

​		（1）<font size=4 color='red'><b>`VHE`</b></font>：是一种硬件辅助虚拟化技术

​		（2）<font size=4 color='red'><b>`QEMU`</b></font>：是一款开源的虚拟机软件

​		（3）<font size=4 color='red'><b>`KVM`</b></font>：是以色列开源组织提出的一款基于Linux内核实现的虚拟化解决方案。

​		（4）<font size=4 color='red'><b>`Strato Virt`</b></font>：是openEuler种面向云数据中心的企业级虚拟化平台，它能支持虚拟机、容器、无服务三种场景。

​		（5）<font size=4 color='red'><b>`Libvirt`</b></font>：是面向虚拟机设计的一套管理工具

## 二、CPU虚拟化

### 1、基本概念

​		（1）虚拟化并不是一个新的技术，早在20世纪60年代的IBM大型机系统中就层涉及过这个话题的内容。
​		（2）CPU的虚拟化技术是指将单台电脑软件环境分割为多个独立分区，每个分区均可以按照需要模拟电脑的一项技术。它的技术实质是通过中间层次实现计算资源的管理和再分配，使资源利用实现最大化。
​		（3）CPU虚拟化指的是将单个物理CPU虚拟化成多个虚拟CPU供虚拟机使用。虚拟CPU分时复用物理CPU，由虚拟机监控器（Virtual Machine Monitor，VMM）对虚拟CPU分配时间片，并同时对虚拟CPU的状态进行管理。
​		（4）CPU的虚拟化技术的优势为虽然虚拟化可以通过软件实现，但是CPU硬件支持的话，执行效率会大大提升，也可以支持64位操作系统。

## 三、内存虚拟化

### 1、基本概念

​		内存虚拟化提供给每个虚拟机一个从零开始的连续的内存空间，并在各虚拟机之间实现内存资源的共享和隔离。

### 2、内存虚拟化的优点

​		（1）<font size=4 color='red'><b>`隔离与保护`</b></font>。数值相同的客户机物理地址被映射到了不同的宿主机物理地址上，虚拟机只能访问VMM分配给它的宿主机物理地址，而不能访问其他虚拟机拥有的物理内存。

​		（2）<font size=4 color='red'><b>`提高内存利用率`</b></font>。由于客户机物理地址是虚拟的，所以客户机物理地址空间都可以从零地址开始。

### 3、I/O虚拟化的三个基本任务

​		（1）<font size=4 color='red'><b>`设备发现`</b></font>。VMM需要提供设备发现的方式，使得客户机操作系统可以发现虚拟设备并且加载相应的驱动程序。设备发现的方式取决于被虚拟的设备类型，包括总线枚举和非枚举两种。

​				① <font size=3 color='blue'><b>`总线枚举`</b></font>。在无虚拟化场景下，可枚举总线（如PCI总线）的配置空间中会保存各个设备的信息。枚举是指操作系统通过访问各个配置空间，从中读取有关设备类型、通信方式等信息。操作系统根据这些信息确定设备是否存在、有效，从而选择加载合适的驱动程序，并通过配置空间的一些字段对相应设备进行资源配置。在虚拟化场景下，VMM不仅需要模拟物理设备的逻辑，还需要模拟PCI总线的行为，才能让客户机操作系统通过“总线枚举”的方式发现这类虚拟设备。

​				② <font size=3 color='blue'><b>`非枚举`</b></font>。在无虚拟化场景下，不可枚举总线（如ISA总线）采用电路连线方式，将设备直接与地址总线、中断及其他控制线路连接起来。这类设备的驱动程序一般会通过特定的方式来检测设备的存在，比如通过in、out指令读取特定I/O端口对应的设备相关的寄存器的状态信息。在虚拟化场景下，VMM只正确模拟这些特定端口的行为，就能让客户机操作系统发现这类虚拟设备。例如，当客户机操作系统访问某个设备对应的I/O端口时，VMM在截获该访问请求之后，可以向客户机操作系统返回一个表征设备存在的信息。

​		（2）<font size=4 color='red'><b>`访问截获`</b></font>。客户机操作系统通过“设备发现”找到了对应的虚拟设备后，将根据设备的接口资源发出I/O请求。

​				① <font size=3 color='blue'><b>`对于基于I/O端口访问的设备`</b></font>，VMM将这类设备的所有I/O端口在I/O许可位图(I/O Permission Bitmap)中都配置为“禁用”状态，使得客户机操作系统在使用I/O指令访问这些I/O端口时触发保护异常，从而实现访问截获。

​				② <font size=3 color='blue'><b>`对于基于 MMIO(Memory-mapped I/O，内存映射1/0)访问的设备`</b></font>，VMM将该MMIO对应的页表项配置为虚拟机不可访问，使得客户机操作系统在访问该设备时触发缺页异常，从而实现访问截获。

​				③ <font size=3 color='blue'><b>`对于基于 DMA(Direct Memory Access,直接内存访问)控制器访间的设备`</b></font>，VMM为每个虚拟机维护一个DMA重映射数据结构。

​				④ <font size=3 color='blue'><b>`对于能产生中断的设备`</b></font>，中断重映射硬件将自动截获设备产生的中断请求，然后查询中断重映射表，来决定如何重新生成中断请求并转发到对应虚拟机中。

​		（3）<font size=4 color='red'><b>`设备模拟`</b></font>。VMM接收到来自虚拟机的I/O请求后，需要模拟物理设备的功能，使得虚拟机对虚拟设备的访问达到访问真实物理设备的效果。

### 4、I/O虚拟化的三种实现方式

​		（1）<font size=4 color='red'><b>`全虚拟化`</b></font>。在无虚拟化场景下，进程发出对物理设备的I/O请求后，通过系统调用陷入内核。内核再调用相应的驱动程序驱动该设备。等到设备处理完毕，再将结果返回到进程。在全虚拟化场景下，客户机进程发出的I/O请求不是直接传递给宿主机驱动程序，而是由VMM 截获后，并由 VMM模拟物理设备的行为。在VMM中，模拟出虚拟设备并处理I/O请求的逻辑模块被称为设备模型。

​		（2）<font size=4 color='red'><b>`半虚拟化`</b></font>。半虚拟化方式将驱动分为前端驱动和后端驱动。传统地，驱动程序完成一次I/O请求通常涉及多次设备交互操作。共享内存机制将这些操作的中间结果进行缓冲，并在请求处理完毕后，再将结果一次性返回给前端。通过这种方式，减少了虚拟机与VMM之间交互的频率，进而减少了虚拟机与VMM之间的上下文切换次数。另外，I/O请求需要借助中断机制传递。在中断处理时，传统的中断处理程序需要确认中断并切换上下文，而该模型使用事件或回调机制实现前后端通信，无须进行上下文切换。因此，前端驱动与后端驱动之间的交互机制可以实现较高性能的I/O虚拟化。

​		（3）<font size=4 color='red'><b>`硬件辅助虚拟化`</b></font>。全虚拟化和半虚拟化的实现方式都有各自的优缺点：前者通用性强，但性能不理想；后者性能相对全虚拟化模拟有提升，但缺乏通用性。为了获得高性能，最理想的方式是让虚拟机直接使用物理设备；为了满足通用性，最理想的方式是让客户机操作系统使用自身的驱动程序就能发现设备、操作设备。硬件辅助I/O虚拟化可同时实现这两个目标。硬件辅助虚拟化将物理设备直接分配给某个虚拟机使用。这种1/O虚拟化技术又称为设备直接分配技术，或I/O透传。在这种方式下，将一个物理设备分配给某个虚拟机后，该虚拟机将独享这个物理设备，其I/O过程不再受 VMM的干涉。设备直接分配技术极大地提高了I/O虚拟化的性能，降低了VMM程序的复杂度，且不需要修改宿主机和客户机操作系统，通用性强。

## 四、openEuler的虚拟化平台——StratoVirt

### 1、StratoVirt的其他特性

​		（1）<font size=4 color='red'><b>`快速冷启动——bootloader`</b></font>。在物理主机上，根据 Linux启动协议，操作系统的启动通常分为五个阶段：

​				① 物理主机上电之后，CPU进入实模式并加载 BIOS,BIOS 首先会进行POST(PowerOn Self-Test，加电自检)，对CPU、内存等硬件设备进行检测和初始化；

​				② 执行MRB(Master Boot Record,主引导扇区）部分的程序，加载 bootloader;

​				③ bootloader 加载操作系统内核镜像到内存，引导操作系统进行启动相关设置；

​				④ 退出实模式，进入保护模式，获取实模式以外的内存大小、硬盘参数、显示相关等信息，随后进行诸如GDT(Global Descriptor Table，全局描述符表)、中断控制器、扩展内存的设置；

​				⑤ 执行Init进程，实现从内核态到用户态的切换，然后便可以运行用户界面等用户态程序。

​		StratoVirt 的bootloader依据 Linux启动协议，对前三个阶段的部分操作进行简化，跳过CPU实模式的阶段直接进人保护模式，提高了系统启动的速度。

​		StratoVirt的bootloader启动虚拟机操作系统的过程可以分为进入保护模式之前和保护模式之后两个阶段。在有实模式的情况下，BIOS通过自检获取许多硬件信息，并将这些信息设置到对应的数据结构、寄存器和硬件设备中。StratoVirt 的bootloader省去了BIOS自检的过程，直接对一些必要信息设置，其中最主要的是零页(zero page)、eB20表和MP(MultiProcessor Specification，多处理器规范)表的设置。零页是内存中位于地址空间最开始的部分，主要存放内核配置和硬件信息，例如内核命令行地址、内核命令行长度、VGA硬件信息等，e820表也是其中的一部分；e820表保存了内存布局的信息,CPU通过读取e820表获取内存布局信息；MP表根据多处理器规范而建立，其中包含了处理器和中断控制器的信息，例如CPU厂商信息、总线信息、I/O中断控制器信息、本地中断控制器信息等。完成上述信息的配置之后，还需设置内存文件系统(initrd)、内核镜像和内核命令行。接下来进入保护模式阶段，bootloader 将设置全局描述符表(GDT)和中断描述符表。全局描述符表记录了段描述符，用于段式内存管理的寻址；中断描述符表保存了中断描述符，CPU执行指令时，通过中断描述符表查找对应的中断处理程序。bootloader 完成了各种信息的设置后，将这些信息传递给CPU，随后CPU初始化并启动操作系统镜像，虚拟机启动完成。

​		（2）<font size=4 color='red'><b>`弹性伸缩——balloon`</b></font>。

​		由于业务的需要，服务器在同一时间可能运行大量虚拟机，而每个虚拟机的内存大小在虚拟机被创建时就已经确定。随着虚拟机内运行负载的变化，虚拟机所使用的内存大小也随之改变。但由于不同虚拟机所运行的服务进程不同，而不同服务进程所使用的内存大小不尽相同，导致有的虚拟机有大量空闲的内存，有的虚拟机内存不足的情况。另一方面，若要调整虚拟机内存大小，则需要关闭虚拟机，这会中断虚拟机内正在执行的任务。

​		为了解决上述的问题，在StratoVirt 中，设计并实现了balloon机制来动态调整虚拟机内存大小。balloon能将虚拟机中暂时空闲的内存回收到宿主机，并由宿主机分配给其他虚拟机。当被回收内存的虚拟机需要内存时，宿主机再将内存归还给该虚拟机。在不影响虚拟机运行的前提下，实现了虚拟机内存资源的弹性伸缩，有效提高了内存的使用率。

​		balloon 基于 virtio框架实现，是位于虚拟机内前后端协同的半虚拟化设备，具有内存回收和释放的功能，同时还能统计虚拟机内存信息。

​		balloon的实现。虚拟机内 balloon设备的前端驱动中有三个环形队列，分别是“充气”队列(IVQ)、“放气”队列(DVQ）和统计队列(SVQ)。虚拟机通过这三个队列与StratoVirt中的balloon后端驱动进行通信，实现回收内存、归还内存和统计内存信息的功能。

​		balloon 回收内存时，向虚拟机内的balloon设备“充气”。balloon按页申请内存并将申请到的内存页的地址保存在IVQ中，随后通过IVQ将页地址分批发送给StratoVirt 中的后端。后端得到信息后，找到相应的内存区间，将对应的页标记为WILLNEED。在balloon前端驱动申请的内存中，存在较多的连续内存段，因此StratoVirt采用了统一标记连续内存的方式，避免每个内存页单独标记，减少了系统调用次数，提高了性能。完成标记后，通知前端，这时宿主机可以重新分配这部分内存。对于归还内存的情况，虚拟机将IVQ里的内存页地址分批出队，存入DVQ中，然后通过DVQ将页地址分批发送给后端，后端将这些页标记为 DONTNEED 并通知前端。被标记为DONTNEED页面的使用权交还给虚拟机，balloon 设备释放这部分内存，供虚拟机内其他程序使用。统计内存信息功能则是由前端驱动收集内存使用状态，将内存状态信息通过SVQ发送给后端，StratoVirt中的balloon后端驱动根据这些内存状态信息判断什么时候能够进行内存的回收，什么时候需要归还内存。
